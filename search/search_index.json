{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>AI-powered Documentation and Test Generation Tool</p> <p> </p> <p>Write-the is an AI-powered documentation and test generation tool that leverages GPTs to automatically write tests, generate documentation, and refactor code. It is designed to streamline the development process, improve code quality, and increase productivity.</p> <p></p>"},{"location":"#real-world-examples","title":"Real-world examples","text":"<ul> <li><code>write-the docs</code> to write the docs for the <code>write-the docs</code> command \ud83e\udd16</li> <li><code>write-the mkdocs</code> to build the documentation site for <code>write-the</code> \ud83e\udd16</li> <li><code>write-the tests</code> to write tests for <code>write-the docs</code> \ud83e\udd16</li> <li><code>write-the docs</code> and <code>write-the mkdocs</code> to build documenation for <code>autoresearcher</code> \ud83e\udd16</li> <li><code>write-the docs</code> and <code>write-the mkdocs</code> to build documenation for <code>hyperspec</code> \ud83e\udd16</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install write-the\n</code></pre>"},{"location":"#features","title":"Features","text":"<p>Write-the offers the following AI-driven features:</p> <ul> <li>Write-the Docs: Automatically generate documentation for your codebase, including class and function descriptions, parameter explanations, and examples.</li> <li>Write-the Tests: Create test cases for your code, ensuring thorough test coverage and better code quality.</li> <li>Write-the Refactor: Receive refactoring suggestions, reduce code complexity, optimize performance, and fix bugs (TBD).</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or higher  </li> <li>OpenAI API key</li> </ul>"},{"location":"#usage","title":"Usage","text":"<p>To use <code>write-the</code>, run the following commands:</p>"},{"location":"#docs","title":"Docs:","text":"<pre><code>write-the docs [OPTIONS] [PATH_TO_SOURCE_CODE]\n</code></pre>"},{"location":"#mkdocs","title":"Mkdocs:","text":"<pre><code>write-the mkdocs [OPTIONS] [PATH_TO_SOURCE_CODE]\n</code></pre>"},{"location":"#tests","title":"Tests:","text":"<pre><code>write-the tests [OPTIONS] [PATH_TO_SOURCE_CODE]\n</code></pre> <p>For detailed information on available options and parameters, refer to the official (<code>write-the</code> generated) documentation.</p>"},{"location":"#roadmap","title":"Roadmap","text":"<p>For a detailed project roadmap, including planned features, improvements, and milestones, please see our Project Timeline.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions from the community. If you would like to contribute to Write-The, please follow these steps:</p> <ul> <li>Fork the repository and create a new branch for your feature or bugfix.</li> <li>Develop your changes and ensure that your code follows the project's coding standards.</li> <li>Create a pull request with a clear description of your changes and any relevant documentation.</li> <li>For more information on contributing, please see our Contributing Guide.</li> </ul>"},{"location":"#license","title":"License","text":"<p><code>write-the</code> is distributed under the terms of the MIT license.</p>"},{"location":"reference/cli/","title":"Cli","text":""},{"location":"reference/cli/#write_the.cli.main.callback","title":"<code>callback(version=typer.Option(None, '-v', '--version', help='Show the pipeline version.', is_eager=True, callback=_print_version, show_default=False))</code>","text":"<p>AI-powered Code Generation and Refactoring Tool</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.callback(context_settings={\"help_option_names\": [\"-h\", \"--help\"]})\ndef callback(\n        version: Optional[bool] = typer.Option(None, '-v', '--version', help=\"Show the pipeline version.\", is_eager=True, callback=_print_version, show_default=False)\n    ):\n\"\"\"\n    AI-powered Code Generation and Refactoring Tool\n    \"\"\"\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.docs","title":"<code>docs(file=typer.Argument(Ellipsis, help='Path to the code file/folder.'), nodes=typer.Option(None, '--node', '-n', help='Generate docs for specific nodes (functions and classes).'), save=typer.Option(False, '--save/--print', '-s', help='Save the docstrings to file or print to stdout.'), context=typer.Option(False, '--context/--no-context', '-c', help='Send context with nodes.'), pretty=typer.Option(False, '--pretty/--plain', '-p', help='Syntax highlight the output.'), force=typer.Option(False, '--force', '-f', help='Generate docstings even if they already exist.'))</code>","text":"<p>Document your code with AI.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef docs(\n    file: Path = typer.Argument(..., help=\"Path to the code file/folder.\"),\n    nodes: List[str] = typer.Option(\n        None,\n        \"--node\",\n        \"-n\",\n        help=\"Generate docs for specific nodes (functions and classes).\",\n    ),\n    save: bool = typer.Option(\n        False, \"--save/--print\", \"-s\", help=\"Save the docstrings to file or print to stdout.\"\n    ),\n    context: bool = typer.Option(\n        False, \"--context/--no-context\", \"-c\", help=\"Send context with nodes.\"\n    ),\n    pretty: bool = typer.Option(\n        False, \"--pretty/--plain\", \"-p\", help=\"Syntax highlight the output.\"\n    ),\n    force: bool = typer.Option(\n        False, \"--force\", \"-f\", help=\"Generate docstings even if they already exist.\"\n    ),\n):\n\"\"\"\n    Document your code with AI.\n    \"\"\"\n    if file.is_dir():\n        files = list_python_files(file)\n    else:\n        assert file.suffix == \".py\"\n        files = [file]\n    for file in files:\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            transient=True,\n        ) as progress:\n            failed = False\n            progress.add_task(description=f\"{file}\", total=None)\n            try:\n                result = write_the_docs(\n                    file, nodes=nodes, force=force, save=save, context=context, pretty=pretty\n                )\n            except Exception:           \n                failed = True\n            progress.stop()\n            if len(files) &gt; 1 or save or failed:\n                icon = \"\u274c\" if failed else \"\u2705\"\n                colour = \"red\" if failed else \"green\"\n                typer.secho(f\"{icon} {file}\", fg=colour)\n            if failed:\n                continue\n            if save:\n                with open(file, \"w\") as f:\n                    f.writelines(result)\n            elif pretty:\n                syntax = Syntax(result, \"python\")\n                console = Console()\n                console.print(syntax)\n            else:\n                typer.echo(result)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.mkdocs","title":"<code>mkdocs(code_dir=typer.Argument(Ellipsis, help='Path to the projects code. Uses docstings to build API reference.', file_okay=False), readme=typer.Option(None, help='Path to projects README (used to create index.md).', dir_okay=False), out_dir=typer.Option(Path('.'), '--out', '-o', help='Path to save output (docs/ and yaml). Defaults to current directory.'))</code>","text":"<p>Generate a mkdocs website for a project including the API reference.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef mkdocs(\n    code_dir: Path = typer.Argument(\n        ...,\n        help=\"Path to the projects code. Uses docstings to build API reference.\",\n        file_okay=False,\n    ),\n    readme: Optional[Path] = typer.Option(\n        None, help=\"Path to projects README (used to create index.md).\", dir_okay=False\n    ),\n    out_dir: Path = typer.Option(\n        Path('.'), \"--out\", \"-o\", help=\"Path to save output (docs/ and yaml). Defaults to current directory.\"\n    ),\n):\n\"\"\"\n    Generate a mkdocs website for a project including the API reference.\n    \"\"\"\n    write_the_mkdocs(code_dir=code_dir, readme=readme, out_dir=out_dir)\n</code></pre>"},{"location":"reference/cli/#write_the.cli.main.tests","title":"<code>tests(file=typer.Argument(Ellipsis, help='Path to the code file/folder.'), tests_dir=typer.Option('tests', '--out', '-o', help='Path to save the docs.'), save=typer.Option(False, '--save/--print', '-s', help='Save the tests to the tests directory or print to stdout.'), pretty=typer.Option(False, '--pretty/--plain', '-p', help='Syntax highlight the output.'), group=typer.Option(False, '--group/--flat', '-g', help='Group the tests into folder or keep them flat.'), force=typer.Option(False, '--force', '-f', help='Generate tests even if they already exist.'), empty=typer.Option(False, '--empty', '-e', help='Save empty files if a test creation fails. This will prevent write-the from regenerating failed test creations.'), gpt_4=typer.Option(False, '--gpt-4', help='Use GPT-4 to generate the tests (requires API will access).'))</code>","text":"<p>Generate tests for your code.</p> Source code in <code>write_the/cli/main.py</code> <pre><code>@app.command()\ndef tests(\n    file: Path = typer.Argument(..., help=\"Path to the code file/folder.\"),\n    tests_dir: Path = typer.Option(\n        'tests', \"--out\", \"-o\", help=\"Path to save the docs.\"\n    ),\n    save: bool = typer.Option(\n        False, \"--save/--print\", \"-s\", help=\"Save the tests to the tests directory or print to stdout.\"\n    ),\n       pretty: bool = typer.Option(\n        False, \"--pretty/--plain\", \"-p\", help=\"Syntax highlight the output.\"\n    ),\n    group: bool = typer.Option(\n        False, \"--group/--flat\", \"-g\", help=\"Group the tests into folder or keep them flat.\"\n    ),\n    force: bool = typer.Option(\n        False, \"--force\", \"-f\", help=\"Generate tests even if they already exist.\"\n    ),\n    empty: bool = typer.Option(\n        False, \"--empty\", \"-e\", help=\"Save empty files if a test creation fails. This will prevent write-the from regenerating failed test creations.\"\n    ),\n    gpt_4: bool = typer.Option(\n        False, \"--gpt-4\", help=\"Use GPT-4 to generate the tests (requires API will access).\"\n    ),\n):\n\"\"\"\n    Generate tests for your code. \n    \"\"\"\n    current_tests = list_python_files(tests_dir)\n    if file.is_dir():\n        files = list_python_files(file)\n    else:\n        assert file.suffix == \".py\"\n        files = [file]\n    for file in files:\n        if file.stem.startswith('_'):\n            continue\n        parts = list(file.parts[1:-1])\n        parts = ['test'] + parts\n        test_file = f\"{'_'.join(parts)}_{file.stem}.py\"\n        if group:\n            parts.append(test_file)\n            test_file = Path(os.path.join(*parts))\n        test_file_path = tests_dir / test_file\n        if test_file_path.exists() and (not force and save) or (test_file in current_tests):\n            continue\n        with Progress(\n            SpinnerColumn(),\n            TextColumn(\"[progress.description]{task.description}\"),\n            transient=True,\n        ) as progress:\n            failed = False\n            progress.add_task(description=f\"{file}\", total=None)\n            try:\n                result = write_the_tests(file, gpt_4=gpt_4)\n            except InvalidInput:\n                failed = True\n                result = \"\"\n            progress.stop()\n            if len(files) &gt; 1 or save or failed:\n                icon = \"\u274c\" if failed else \"\u2705\"\n                colour = \"red\" if failed else \"green\"\n                typer.secho(f\"{icon} {file}\", fg=colour)\n            if failed and not empty:\n                continue\n            if save:\n                # create test file\n                tests_dir.mkdir(exist_ok=True)\n                test_file_path.parent.mkdir(exist_ok=True, parents=True)\n                with open(test_file_path, \"w\") as f:\n                    f.writelines(result)\n            elif pretty:\n                syntax = Syntax(result, \"python\")\n                console = Console()\n                console.print(syntax)\n            else:\n                typer.echo(result)\n</code></pre>"},{"location":"reference/cst/","title":"Cst","text":""},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector","title":"<code>FunctionAndClassCollector</code>","text":"<p>         Bases: <code>cst.CSTVisitor</code></p> Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>class FunctionAndClassCollector(cst.CSTVisitor):\n    def __init__(self, force):\n\"\"\"\n        Initializes the FunctionAndClassCollector.\n        Args:\n          force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n        \"\"\"\n        self.functions = []\n        self.classes = []\n        self.current_class = None\n        self.force = force\n\n    def visit_FunctionDef(self, node: cst.FunctionDef) -&gt; None:\n\"\"\"\n        Visits a FunctionDef node and adds it to the list of functions if it does not have a docstring or if `force` is `True`.\n        Args:\n          node (cst.FunctionDef): The FunctionDef node to visit.\n        \"\"\"\n        name = (\n            f\"{self.current_class}.{node.name.value}\"\n            if self.current_class\n            else node.name.value\n        )\n        if not has_docstring(node) or self.force:\n            self.functions.append(name)\n\n    def visit_ClassDef(self, node: cst.ClassDef) -&gt; None:\n\"\"\"\n        Visits a ClassDef node and adds it to the list of classes if it does not have a docstring or if `force` is `True`.\n        Args:\n          node (cst.ClassDef): The ClassDef node to visit.\n        \"\"\"\n        self.current_class = node.name.value\n        if not has_docstring(node) or self.force:\n            self.classes.append(node.name.value)\n        # self.visit_ClassDef(node)  # Call the superclass method to continue the visit\n\n    def leave_ClassDef(self, node: cst.ClassDef) -&gt; None:\n        self.current_class = None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.__init__","title":"<code>__init__(force)</code>","text":"<p>Initializes the FunctionAndClassCollector.</p> <p>Parameters:</p> Name Type Description Default <code>force</code> <code>bool</code> <p>Whether to force the collection of functions and classes even if they have docstrings.</p> required Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def __init__(self, force):\n\"\"\"\n    Initializes the FunctionAndClassCollector.\n    Args:\n      force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n    \"\"\"\n    self.functions = []\n    self.classes = []\n    self.current_class = None\n    self.force = force\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.visit_ClassDef","title":"<code>visit_ClassDef(node)</code>","text":"<p>Visits a ClassDef node and adds it to the list of classes if it does not have a docstring or if <code>force</code> is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.ClassDef</code> <p>The ClassDef node to visit.</p> required Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def visit_ClassDef(self, node: cst.ClassDef) -&gt; None:\n\"\"\"\n    Visits a ClassDef node and adds it to the list of classes if it does not have a docstring or if `force` is `True`.\n    Args:\n      node (cst.ClassDef): The ClassDef node to visit.\n    \"\"\"\n    self.current_class = node.name.value\n    if not has_docstring(node) or self.force:\n        self.classes.append(node.name.value)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.FunctionAndClassCollector.visit_FunctionDef","title":"<code>visit_FunctionDef(node)</code>","text":"<p>Visits a FunctionDef node and adds it to the list of functions if it does not have a docstring or if <code>force</code> is <code>True</code>.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.FunctionDef</code> <p>The FunctionDef node to visit.</p> required Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def visit_FunctionDef(self, node: cst.FunctionDef) -&gt; None:\n\"\"\"\n    Visits a FunctionDef node and adds it to the list of functions if it does not have a docstring or if `force` is `True`.\n    Args:\n      node (cst.FunctionDef): The FunctionDef node to visit.\n    \"\"\"\n    name = (\n        f\"{self.current_class}.{node.name.value}\"\n        if self.current_class\n        else node.name.value\n    )\n    if not has_docstring(node) or self.force:\n        self.functions.append(name)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.function_and_class_collector.get_node_names","title":"<code>get_node_names(tree, force)</code>","text":"<p>Gets the names of functions and classes from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The CST tree to traverse.</p> required <code>force</code> <code>bool</code> <p>Whether to force the collection of functions and classes even if they have docstrings.</p> required <p>Returns:</p> Type Description <p>list[str]: A list of function and class names.</p> Source code in <code>write_the/cst/function_and_class_collector.py</code> <pre><code>def get_node_names(tree, force):\n\"\"\"\n    Gets the names of functions and classes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to traverse.\n      force (bool): Whether to force the collection of functions and classes even if they have docstrings.\n    Returns:\n      list[str]: A list of function and class names.\n    \"\"\"\n    collector = FunctionAndClassCollector(force)\n    tree.visit(collector)\n    return collector.functions + collector.classes\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder","title":"<code>DocstringAdder</code>","text":"<p>         Bases: <code>cst.CSTTransformer</code></p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>class DocstringAdder(cst.CSTTransformer):\n    def __init__(self, docstrings, force):\n        self.docstrings = docstrings\n        self.current_class = None\n        self.force = force\n\n    def leave_FunctionDef(\n        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n    ) -&gt; cst.FunctionDef:\n\"\"\"\n        Adds a docstring to a function definition.\n        Args:\n          original_node (cst.FunctionDef): The original CST node.\n          updated_node (cst.FunctionDef): The updated CST node.\n        Returns:\n          cst.FunctionDef: The updated CST node with a docstring added.\n        \"\"\"\n        return self.add_docstring(updated_node)\n\n    def visit_ClassDef(\n            self, original_node: cst.ClassDef\n    ) -&gt; None:\n        self.current_class = original_node.name.value\n\n    def leave_ClassDef(\n        self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n    ) -&gt; cst.ClassDef:\n\"\"\"\n        Adds a docstring to a class definition.\n        Args:\n          original_node (cst.ClassDef): The original CST node.\n          updated_node (cst.ClassDef): The updated CST node.\n        Returns:\n          cst.ClassDef: The updated CST node with a docstring added.\n        \"\"\"\n        self.current_class = None\n        updated_node = self.add_docstring(updated_node)\n        return updated_node\n\n    def add_docstring(self, node):\n\"\"\"\n        Adds a docstring to a CST node.\n        Args:\n            node (cst.CSTNode): The CST node to add a docstring to.\n        Returns:\n            cst.CSTNode: The updated CST node with a docstring added.\n        \"\"\"\n        key = (\n            f\"{self.current_class}.{node.name.value}\"\n            if self.current_class\n            else node.name.value\n        )\n        docstring = self.docstrings.get(key, None)\n        if docstring and (self.force or not has_docstring(node)):\n            if self.force and has_docstring(node):\n                # Remove existing docstring\n                node = remove_docstring(node)\n            dedented_docstring = textwrap.dedent(docstring)\n            indented_docstring = textwrap.indent(dedented_docstring, '    ')\n            new_docstring = cst.parse_statement(f'\"\"\"{indented_docstring}    \"\"\"')\n            body = node.body.with_changes(body=[new_docstring] + list(node.body.body))\n            return node.with_changes(body=body)\n\n        return node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder.add_docstring","title":"<code>add_docstring(node)</code>","text":"<p>Adds a docstring to a CST node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The CST node to add a docstring to.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The updated CST node with a docstring added.</p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>def add_docstring(self, node):\n\"\"\"\n    Adds a docstring to a CST node.\n    Args:\n        node (cst.CSTNode): The CST node to add a docstring to.\n    Returns:\n        cst.CSTNode: The updated CST node with a docstring added.\n    \"\"\"\n    key = (\n        f\"{self.current_class}.{node.name.value}\"\n        if self.current_class\n        else node.name.value\n    )\n    docstring = self.docstrings.get(key, None)\n    if docstring and (self.force or not has_docstring(node)):\n        if self.force and has_docstring(node):\n            # Remove existing docstring\n            node = remove_docstring(node)\n        dedented_docstring = textwrap.dedent(docstring)\n        indented_docstring = textwrap.indent(dedented_docstring, '    ')\n        new_docstring = cst.parse_statement(f'\"\"\"{indented_docstring}    \"\"\"')\n        body = node.body.with_changes(body=[new_docstring] + list(node.body.body))\n        return node.with_changes(body=body)\n\n    return node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder.leave_ClassDef","title":"<code>leave_ClassDef(original_node, updated_node)</code>","text":"<p>Adds a docstring to a class definition.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.ClassDef</code> <p>The original CST node.</p> required <code>updated_node</code> <code>cst.ClassDef</code> <p>The updated CST node.</p> required <p>Returns:</p> Type Description <code>cst.ClassDef</code> <p>cst.ClassDef: The updated CST node with a docstring added.</p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>def leave_ClassDef(\n    self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.ClassDef:\n\"\"\"\n    Adds a docstring to a class definition.\n    Args:\n      original_node (cst.ClassDef): The original CST node.\n      updated_node (cst.ClassDef): The updated CST node.\n    Returns:\n      cst.ClassDef: The updated CST node with a docstring added.\n    \"\"\"\n    self.current_class = None\n    updated_node = self.add_docstring(updated_node)\n    return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_adder.DocstringAdder.leave_FunctionDef","title":"<code>leave_FunctionDef(original_node, updated_node)</code>","text":"<p>Adds a docstring to a function definition.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.FunctionDef</code> <p>The original CST node.</p> required <code>updated_node</code> <code>cst.FunctionDef</code> <p>The updated CST node.</p> required <p>Returns:</p> Type Description <code>cst.FunctionDef</code> <p>cst.FunctionDef: The updated CST node with a docstring added.</p> Source code in <code>write_the/cst/docstring_adder.py</code> <pre><code>def leave_FunctionDef(\n    self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.FunctionDef:\n\"\"\"\n    Adds a docstring to a function definition.\n    Args:\n      original_node (cst.FunctionDef): The original CST node.\n      updated_node (cst.FunctionDef): The updated CST node.\n    Returns:\n      cst.FunctionDef: The updated CST node with a docstring added.\n    \"\"\"\n    return self.add_docstring(updated_node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover","title":"<code>DocstringRemover</code>","text":"<p>         Bases: <code>cst.CSTTransformer</code></p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>class DocstringRemover(cst.CSTTransformer):\n    def __init__(self, nodes):\n\"\"\"\n        Initializes the DocstringRemover object.\n        Args:\n          nodes (list): A list of nodes to remove docstrings from.\n        \"\"\"\n        self.nodes = nodes\n\n    def leave_FunctionDef(\n        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n    ) -&gt; cst.FunctionDef:\n\"\"\"\n        Removes the docstring from a FunctionDef node if it is in the list of nodes.\n        Args:\n          original_node (cst.FunctionDef): The original FunctionDef node.\n          updated_node (cst.FunctionDef): The updated FunctionDef node.\n        Returns:\n          cst.FunctionDef: The updated FunctionDef node with the docstring removed if it is in the list of nodes.\n        \"\"\"\n        if original_node.name.value in self.nodes:\n            return remove_docstring(updated_node)\n        return updated_node\n\n    def leave_ClassDef(\n        self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n    ) -&gt; cst.ClassDef:\n\"\"\"\n        Removes the docstring from a ClassDef node if it is in the list of nodes.\n        Args:\n          original_node (cst.ClassDef): The original ClassDef node.\n          updated_node (cst.ClassDef): The updated ClassDef node.\n        Returns:\n          cst.ClassDef: The updated ClassDef node with the docstring removed if it is in the list of nodes.\n        \"\"\"\n        if original_node.name.value in self.nodes:\n            return remove_docstring(updated_node)\n        return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover.__init__","title":"<code>__init__(nodes)</code>","text":"<p>Initializes the DocstringRemover object.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>A list of nodes to remove docstrings from.</p> required Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def __init__(self, nodes):\n\"\"\"\n    Initializes the DocstringRemover object.\n    Args:\n      nodes (list): A list of nodes to remove docstrings from.\n    \"\"\"\n    self.nodes = nodes\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover.leave_ClassDef","title":"<code>leave_ClassDef(original_node, updated_node)</code>","text":"<p>Removes the docstring from a ClassDef node if it is in the list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.ClassDef</code> <p>The original ClassDef node.</p> required <code>updated_node</code> <code>cst.ClassDef</code> <p>The updated ClassDef node.</p> required <p>Returns:</p> Type Description <code>cst.ClassDef</code> <p>cst.ClassDef: The updated ClassDef node with the docstring removed if it is in the list of nodes.</p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def leave_ClassDef(\n    self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.ClassDef:\n\"\"\"\n    Removes the docstring from a ClassDef node if it is in the list of nodes.\n    Args:\n      original_node (cst.ClassDef): The original ClassDef node.\n      updated_node (cst.ClassDef): The updated ClassDef node.\n    Returns:\n      cst.ClassDef: The updated ClassDef node with the docstring removed if it is in the list of nodes.\n    \"\"\"\n    if original_node.name.value in self.nodes:\n        return remove_docstring(updated_node)\n    return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.DocstringRemover.leave_FunctionDef","title":"<code>leave_FunctionDef(original_node, updated_node)</code>","text":"<p>Removes the docstring from a FunctionDef node if it is in the list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.FunctionDef</code> <p>The original FunctionDef node.</p> required <code>updated_node</code> <code>cst.FunctionDef</code> <p>The updated FunctionDef node.</p> required <p>Returns:</p> Type Description <code>cst.FunctionDef</code> <p>cst.FunctionDef: The updated FunctionDef node with the docstring removed if it is in the list of nodes.</p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def leave_FunctionDef(\n    self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.FunctionDef:\n\"\"\"\n    Removes the docstring from a FunctionDef node if it is in the list of nodes.\n    Args:\n      original_node (cst.FunctionDef): The original FunctionDef node.\n      updated_node (cst.FunctionDef): The updated FunctionDef node.\n    Returns:\n      cst.FunctionDef: The updated FunctionDef node with the docstring removed if it is in the list of nodes.\n    \"\"\"\n    if original_node.name.value in self.nodes:\n        return remove_docstring(updated_node)\n    return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.docstring_remover.remove_docstrings","title":"<code>remove_docstrings(tree, nodes)</code>","text":"<p>Removes the docstrings from a tree of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The tree of nodes to remove the docstrings from.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to remove docstrings from.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The tree of nodes with the docstrings removed.</p> Source code in <code>write_the/cst/docstring_remover.py</code> <pre><code>def remove_docstrings(tree, nodes):\n\"\"\"\n    Removes the docstrings from a tree of nodes.\n    Args:\n      tree (cst.CSTNode): The tree of nodes to remove the docstrings from.\n      nodes (list): A list of nodes to remove docstrings from.\n    Returns:\n      cst.CSTNode: The tree of nodes with the docstrings removed.\n    \"\"\"\n    remover = DocstringRemover(nodes)\n    tree = tree.visit(remover)\n    return tree\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.get_docstring","title":"<code>get_docstring(node)</code>","text":"<p>Retrieves the docstring of a CSTNode if it has one.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The node to check.</p> required <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Optional[str]: The docstring of the node if it exists, None otherwise.</p> Notes <p>Only retrieves docstrings for FunctionDef and ClassDef nodes.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def get_docstring(node: cst.CSTNode) -&gt; Optional[str]:\n\"\"\"\n    Retrieves the docstring of a CSTNode if it has one.\n    Args:\n        node (cst.CSTNode): The node to check.\n    Returns:\n        Optional[str]: The docstring of the node if it exists, None otherwise.\n    Notes:\n        Only retrieves docstrings for FunctionDef and ClassDef nodes.\n    \"\"\"\n    if has_docstring(node):\n        body = node.body.body\n        stmt = body[0].body[0]\n        return stmt.value.value\n    return None\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.has_docstring","title":"<code>has_docstring(node)</code>","text":"<p>Checks if a CSTNode has a docstring.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The node to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether or not the node has a docstring.</p> Notes <p>Only checks for docstrings on FunctionDef and ClassDef nodes.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def has_docstring(node: cst.CSTNode) -&gt; bool:\n\"\"\"\n    Checks if a CSTNode has a docstring.\n    Args:\n      node (cst.CSTNode): The node to check.\n    Returns:\n      bool: Whether or not the node has a docstring.\n    Notes:\n      Only checks for docstrings on FunctionDef and ClassDef nodes.\n    \"\"\"\n    if isinstance(node, cst.FunctionDef) or isinstance(node, cst.ClassDef):\n        body = node.body.body\n        if body and isinstance(body[0], cst.SimpleStatementLine):\n            stmt = body[0].body[0]\n            if isinstance(stmt, cst.Expr) and isinstance(stmt.value, cst.SimpleString):\n                return True\n    return False\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.nodes_to_tree","title":"<code>nodes_to_tree(nodes)</code>","text":"<p>Converts a list of CSTNodes into a CSTModule.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list[cst.CSTNode]</code> <p>The list of nodes to convert.</p> required <p>Returns:</p> Type Description <p>cst.Module: The CSTModule containing the given nodes.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def nodes_to_tree(nodes):\n\"\"\"\n    Converts a list of CSTNodes into a CSTModule.\n    Args:\n      nodes (list[cst.CSTNode]): The list of nodes to convert.\n    Returns:\n      cst.Module: The CSTModule containing the given nodes.\n    \"\"\"\n    module = cst.Module(body=nodes)\n    return module\n</code></pre>"},{"location":"reference/cst/#write_the.cst.utils.remove_docstring","title":"<code>remove_docstring(node)</code>","text":"<p>Removes the docstring from a node.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.CSTNode</code> <p>The node to remove the docstring from.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The node with the docstring removed.</p> Source code in <code>write_the/cst/utils.py</code> <pre><code>def remove_docstring(node):\n\"\"\"\n    Removes the docstring from a node.\n    Args:\n      node (cst.CSTNode): The node to remove the docstring from.\n    Returns:\n      cst.CSTNode: The node with the docstring removed.\n    \"\"\"\n    if not node.body.body:\n        return node\n    first_stmt = node.body.body[0]\n    if isinstance(first_stmt, cst.SimpleStatementLine):\n        stmt = first_stmt.body[0]\n        if isinstance(stmt, cst.Expr) and isinstance(stmt.value, cst.SimpleString):\n            new_body = node.body.with_changes(body=node.body.body[1:])\n            return node.with_changes(body=new_body)\n    return node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.NodeExtractor","title":"<code>NodeExtractor</code>","text":"<p>         Bases: <code>cst.CSTVisitor</code></p> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>class NodeExtractor(cst.CSTVisitor):\n    def __init__(self, nodes):\n        self.nodes = nodes\n        self.extracted_nodes = []\n\n    def visit_FunctionDef(self, node: cst.FunctionDef):\n\"\"\"\n        Visits a FunctionDef node and adds it to the extracted_nodes list if it is in the nodes list.\n        Args:\n          node (cst.FunctionDef): The FunctionDef node to visit.\n        Side Effects:\n          Adds the node to the extracted_nodes list if it is in the nodes list.\n        \"\"\"\n        if node.name.value in self.nodes:\n            self.extracted_nodes.append(node)\n\n    def visit_ClassDef(self, node: cst.ClassDef):\n\"\"\"\n        Visits a ClassDef node and adds it to the extracted_nodes list if it is in the nodes list.\n        Args:\n          node (cst.ClassDef): The ClassDef node to visit.\n        Side Effects:\n          Adds the node to the extracted_nodes list if it is in the nodes list.\n        \"\"\"\n        if node.name.value in self.nodes:\n            self.extracted_nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.NodeExtractor.visit_ClassDef","title":"<code>visit_ClassDef(node)</code>","text":"<p>Visits a ClassDef node and adds it to the extracted_nodes list if it is in the nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.ClassDef</code> <p>The ClassDef node to visit.</p> required Side Effects <p>Adds the node to the extracted_nodes list if it is in the nodes list.</p> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>def visit_ClassDef(self, node: cst.ClassDef):\n\"\"\"\n    Visits a ClassDef node and adds it to the extracted_nodes list if it is in the nodes list.\n    Args:\n      node (cst.ClassDef): The ClassDef node to visit.\n    Side Effects:\n      Adds the node to the extracted_nodes list if it is in the nodes list.\n    \"\"\"\n    if node.name.value in self.nodes:\n        self.extracted_nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.NodeExtractor.visit_FunctionDef","title":"<code>visit_FunctionDef(node)</code>","text":"<p>Visits a FunctionDef node and adds it to the extracted_nodes list if it is in the nodes list.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>cst.FunctionDef</code> <p>The FunctionDef node to visit.</p> required Side Effects <p>Adds the node to the extracted_nodes list if it is in the nodes list.</p> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>def visit_FunctionDef(self, node: cst.FunctionDef):\n\"\"\"\n    Visits a FunctionDef node and adds it to the extracted_nodes list if it is in the nodes list.\n    Args:\n      node (cst.FunctionDef): The FunctionDef node to visit.\n    Side Effects:\n      Adds the node to the extracted_nodes list if it is in the nodes list.\n    \"\"\"\n    if node.name.value in self.nodes:\n        self.extracted_nodes.append(node)\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_extractor.extract_nodes_from_tree","title":"<code>extract_nodes_from_tree(tree, nodes)</code>","text":"<p>Extracts nodes from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The CST tree to extract nodes from.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to extract.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of extracted nodes.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; extract_nodes_from_tree(tree, nodes)\n[cst.FunctionDef, cst.ClassDef]\n</code></pre> Source code in <code>write_the/cst/node_extractor.py</code> <pre><code>def extract_nodes_from_tree(tree, nodes):\n\"\"\"\n    Extracts nodes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to extract nodes from.\n      nodes (list): A list of nodes to extract.\n    Returns:\n      list: A list of extracted nodes.\n    Examples:\n      &gt;&gt;&gt; extract_nodes_from_tree(tree, nodes)\n      [cst.FunctionDef, cst.ClassDef]\n    \"\"\"\n    extractor = NodeExtractor(nodes)\n    tree.visit(extractor)\n    return extractor.extracted_nodes\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover","title":"<code>NodeRemover</code>","text":"<p>         Bases: <code>cst.CSTTransformer</code></p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>class NodeRemover(cst.CSTTransformer):\n    def __init__(self, nodes):\n\"\"\"\n        Initializes a NodeRemover instance.\n        Args:\n          nodes (list): A list of nodes to remove.\n        \"\"\"\n        self.nodes = nodes\n\n    def leave_FunctionDef(\n        self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n    ) -&gt; cst.RemovalSentinel:\n\"\"\"\n        Removes a FunctionDef node from the tree if it is in the list of nodes.\n        Args:\n          original_node (cst.FunctionDef): The original FunctionDef node.\n          updated_node (cst.FunctionDef): The updated FunctionDef node.\n        Returns:\n          cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n        \"\"\"\n        if original_node.name.value in self.nodes:\n            return cst.RemoveFromParent()\n        return updated_node\n\n    def leave_ClassDef(\n        self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n    ) -&gt; cst.RemovalSentinel:\n\"\"\"\n        Removes a ClassDef node from the tree if it is in the list of nodes.\n        Args:\n          original_node (cst.ClassDef): The original ClassDef node.\n          updated_node (cst.ClassDef): The updated ClassDef node.\n        Returns:\n          cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n        \"\"\"\n        if original_node.name.value in self.nodes:\n            return cst.RemoveFromParent()\n        return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover.__init__","title":"<code>__init__(nodes)</code>","text":"<p>Initializes a NodeRemover instance.</p> <p>Parameters:</p> Name Type Description Default <code>nodes</code> <code>list</code> <p>A list of nodes to remove.</p> required Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def __init__(self, nodes):\n\"\"\"\n    Initializes a NodeRemover instance.\n    Args:\n      nodes (list): A list of nodes to remove.\n    \"\"\"\n    self.nodes = nodes\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover.leave_ClassDef","title":"<code>leave_ClassDef(original_node, updated_node)</code>","text":"<p>Removes a ClassDef node from the tree if it is in the list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.ClassDef</code> <p>The original ClassDef node.</p> required <code>updated_node</code> <code>cst.ClassDef</code> <p>The updated ClassDef node.</p> required <p>Returns:</p> Type Description <code>cst.RemovalSentinel</code> <p>cst.RemovalSentinel: A sentinel indicating whether the node should be removed.</p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def leave_ClassDef(\n    self, original_node: cst.ClassDef, updated_node: cst.ClassDef\n) -&gt; cst.RemovalSentinel:\n\"\"\"\n    Removes a ClassDef node from the tree if it is in the list of nodes.\n    Args:\n      original_node (cst.ClassDef): The original ClassDef node.\n      updated_node (cst.ClassDef): The updated ClassDef node.\n    Returns:\n      cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n    \"\"\"\n    if original_node.name.value in self.nodes:\n        return cst.RemoveFromParent()\n    return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.NodeRemover.leave_FunctionDef","title":"<code>leave_FunctionDef(original_node, updated_node)</code>","text":"<p>Removes a FunctionDef node from the tree if it is in the list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>original_node</code> <code>cst.FunctionDef</code> <p>The original FunctionDef node.</p> required <code>updated_node</code> <code>cst.FunctionDef</code> <p>The updated FunctionDef node.</p> required <p>Returns:</p> Type Description <code>cst.RemovalSentinel</code> <p>cst.RemovalSentinel: A sentinel indicating whether the node should be removed.</p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def leave_FunctionDef(\n    self, original_node: cst.FunctionDef, updated_node: cst.FunctionDef\n) -&gt; cst.RemovalSentinel:\n\"\"\"\n    Removes a FunctionDef node from the tree if it is in the list of nodes.\n    Args:\n      original_node (cst.FunctionDef): The original FunctionDef node.\n      updated_node (cst.FunctionDef): The updated FunctionDef node.\n    Returns:\n      cst.RemovalSentinel: A sentinel indicating whether the node should be removed.\n    \"\"\"\n    if original_node.name.value in self.nodes:\n        return cst.RemoveFromParent()\n    return updated_node\n</code></pre>"},{"location":"reference/cst/#write_the.cst.node_remover.remove_nodes_from_tree","title":"<code>remove_nodes_from_tree(tree, nodes)</code>","text":"<p>Removes nodes from a CST tree.</p> <p>Parameters:</p> Name Type Description Default <code>tree</code> <code>cst.CSTNode</code> <p>The CST tree to remove nodes from.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to remove.</p> required <p>Returns:</p> Type Description <p>cst.CSTNode: The updated CST tree.</p> Source code in <code>write_the/cst/node_remover.py</code> <pre><code>def remove_nodes_from_tree(tree, nodes):\n\"\"\"\n    Removes nodes from a CST tree.\n    Args:\n      tree (cst.CSTNode): The CST tree to remove nodes from.\n      nodes (list): A list of nodes to remove.\n    Returns:\n      cst.CSTNode: The updated CST tree.\n    \"\"\"\n    remover = NodeRemover(nodes)\n    tree = tree.visit(remover)\n    return tree\n</code></pre>"},{"location":"reference/docs/","title":"Docs","text":""},{"location":"reference/docs/#write_the.docs.write.write_the_docs","title":"<code>write_the_docs(filename, nodes=[], force=False, save=False, context=True, pretty=False)</code>","text":"<p>Generates docstrings for a given file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>The path to the file to generate docstrings for.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to generate docstrings for.</p> <code>[]</code> <code>force</code> <code>bool</code> <p>Whether to overwrite existing docstrings.</p> <code>False</code> <code>save</code> <code>bool</code> <p>Whether to generate docstrings in the same file.</p> <code>False</code> <code>context</code> <code>bool</code> <p>Whether to send context with the code (can improve docstings).</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The source code with the generated docstrings.</p> Notes <p>If <code>nodes</code> is provided, <code>force</code> is set to <code>True</code> and <code>context</code> is set to <code>False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_the_docs(\"example.py\")\n\"def add(a, b):\n    \"\"\"Sums 2 numbers.\n    Args:\n        a (int): The first number to add.\n        b (int): The second number to add.\n    Returns:\n        int: The sum of `a` and `b`.\n    \"\"\"\n    return a + b\"\n</code></pre> Source code in <code>write_the/docs/write.py</code> <pre><code>def write_the_docs(\n    filename: Path, nodes=[], force=False, save=False, context=True, pretty=False\n) -&gt; str:\n\"\"\"\n    Generates docstrings for a given file.\n    Args:\n      filename (Path): The path to the file to generate docstrings for.\n      nodes (list): A list of nodes to generate docstrings for.\n      force (bool): Whether to overwrite existing docstrings.\n      save (bool): Whether to generate docstrings in the same file.\n      context (bool): Whether to send context with the code (can improve docstings).\n    Returns:\n      str: The source code with the generated docstrings.\n    Notes:\n      If `nodes` is provided, `force` is set to `True` and `context` is set to `False`.\n    Examples:\n      &gt;&gt;&gt; write_the_docs(\"example.py\")\n      \"def add(a, b):\n          \\\"\\\"\\\"Sums 2 numbers.\n          Args:\n              a (int): The first number to add.\n              b (int): The second number to add.\n          Returns:\n              int: The sum of `a` and `b`.\n          \\\"\\\"\\\"\n          return a + b\"\n    \"\"\"\n    with open(filename, \"r\") as file:\n        source_code = file.read()\n    if pretty:\n        source_code = format_str(source_code, mode=FileMode())\n    tree = cst.parse_module(source_code)\n    extract_specific_nodes = False\n\n    if nodes:\n        extract_specific_nodes = True\n        force = True\n    else:\n        nodes = get_node_names(tree, force)\n    if not nodes:\n        return source_code\n    tree_without_docstrings = remove_docstrings(tree, nodes)\n    if not context:\n        if extract_specific_nodes:\n            extracted_nodes = extract_nodes_from_tree(tree_without_docstrings, nodes)\n            processed_tree = nodes_to_tree(extracted_nodes)\n        else:\n            all_nodes = get_node_names(tree, False)\n            nodes_to_remove = [n for n in all_nodes if n not in nodes]\n            processed_tree = remove_nodes_from_tree(\n                tree_without_docstrings, nodes_to_remove\n            )\n        code = processed_tree.code\n    else:\n        code = tree_without_docstrings.code\n    result = run(code=code, nodes=nodes)\n    docstring_dict = {}\n    for line in result.split(\"\\n\\n\"):\n        line = line.strip()\n        if not line:\n            continue\n        (node_name, docsting) = line.split(\":\", 1)\n        docstring_dict[node_name] = docsting + \"\\n\"\n    modified_tree = tree_without_docstrings.visit(DocstringAdder(docstring_dict, force))\n    if not save and extract_specific_nodes:\n        extracted_nodes = extract_nodes_from_tree(modified_tree, nodes)\n        modified_tree = nodes_to_tree(extracted_nodes)\n    if pretty:\n\n        return format_str(modified_tree.code, mode=FileMode())\n    return modified_tree.code\n</code></pre>"},{"location":"reference/docs/#write_the.docs.chain.run","title":"<code>run(code, nodes)</code>","text":"<p>Generates docstrings for a given code and list of nodes.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code to generate docstrings for.</p> required <code>nodes</code> <code>list</code> <p>A list of nodes to generate docstrings for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated docstrings.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; run('from langchain.prompts import PromptTemplate', ['PromptTemplate'])\n'PromptTemplate:\n  A class for generating prompts.\n  Attributes:\n    input_variables (list): A list of input variables for the prompt.\n    template (str): The template for the prompt.'\n</code></pre> Source code in <code>write_the/docs/chain.py</code> <pre><code>def run(code, nodes: list) -&gt; str:\n\"\"\"\n    Generates docstrings for a given code and list of nodes.\n    Args:\n      code (str): The code to generate docstrings for.\n      nodes (list): A list of nodes to generate docstrings for.\n    Returns:\n      str: The generated docstrings.\n    Examples:\n      &gt;&gt;&gt; run('from langchain.prompts import PromptTemplate', ['PromptTemplate'])\n      'PromptTemplate:\n        A class for generating prompts.\n        Attributes:\n          input_variables (list): A list of input variables for the prompt.\n          template (str): The template for the prompt.'\n    \"\"\"\n    llm = OpenAI(temperature=0, max_tokens=-1)\n    docs_prompt = PromptTemplate(input_variables=[\"code\", \"nodes\"], template=docs_template)\n    docs_chain = LLMChain(llm=llm, prompt=docs_prompt)\n    nodes = \",\".join(nodes)\n    return docs_chain.predict(code=code, nodes=nodes)\n</code></pre>"},{"location":"reference/mkdocs/","title":"Mkdocs","text":""},{"location":"reference/mkdocs/#write_the.mkdocs.write.write_the_mkdocs","title":"<code>write_the_mkdocs(code_dir, readme=None, out_dir=Path('.'), project_name=None)</code>","text":"<p>Generates a mkdocs project from a directory of python files.</p> <p>Parameters:</p> Name Type Description Default <code>code_dir</code> <code>Path</code> <p>The directory containing the python files.</p> required <code>readme</code> <code>Path</code> <p>The readme file to include in the project. Defaults to None.</p> <code>None</code> <code>out_dir</code> <code>Path</code> <p>The directory to write the project to. Defaults to the current directory.</p> <code>Path('.')</code> <code>project_name</code> <code>str</code> <p>The name of the project. Defaults to the name of the code_dir.</p> <code>None</code> Notes <p>If readme is not provided, the project will not have a home page. If project_name is not provided, the project will be named after the code_dir.</p> Side Effects <p>Creates a mkdocs project in the out_dir. Creates a .github/workflows/mkdocs.yml file in the out_dir.</p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>write_the/mkdocs/write.py</code> <pre><code>def write_the_mkdocs(code_dir: Path, readme: Path = None, out_dir: Path = Path('.'), project_name=None):\n\"\"\"\n    Generates a mkdocs project from a directory of python files.\n    Args:\n      code_dir (Path): The directory containing the python files.\n      readme (Path, optional): The readme file to include in the project. Defaults to None.\n      out_dir (Path, optional): The directory to write the project to. Defaults to the current directory.\n      project_name (str, optional): The name of the project. Defaults to the name of the code_dir.\n    Notes:\n      If readme is not provided, the project will not have a home page.\n      If project_name is not provided, the project will be named after the code_dir.\n    Side Effects:\n      Creates a mkdocs project in the out_dir.\n      Creates a .github/workflows/mkdocs.yml file in the out_dir.\n    Returns:\n      None\n    \"\"\"\n    files = list_python_files(code_dir)\n    groups = [path.stem for path in code_dir.glob(\"*\") if not path.stem.startswith(\"_\")]\n\n    if not project_name:\n        project_name = code_dir.name\n    mkdocs = mkdocs_template.format(project_name=project_name)\n    references = defaultdict(list)\n    for file in files:\n        if file.name.startswith(\"_\"):\n            continue\n        key = \"index\"\n        for group in groups:\n            if f\"{code_dir.name}/{group}/\" in str(file) or f\"{code_dir.name}/{group}.\" in str(file):\n                key = group\n                break\n        module = str(file).rstrip(\".py\").replace(\"/\", \".\")  # breaks on windows?\n        references[key].append(f\"::: {module}\")\n    docs_dir = out_dir / 'docs'\n    reference_path = docs_dir / \"reference\"\n    reference_path.mkdir(parents=True, exist_ok=True)\n    for doc in references:\n        with open(f\"{reference_path}/{doc}.md\", \"w\") as f:\n            for ref in references[doc]:\n                f.write(ref + \"\\n\\n\")\n    if readme:\n        index_text = f\"---\\ntitle: Home\\n---\\n{readme.read_text()}\"\n        (docs_dir / \"index.md\").write_text(index_text)\n    if not (out_dir / \"mkdocs.yml\").exists():\n        (out_dir / \"mkdocs.yml\").write_text(mkdocs)\n    action_path = out_dir / \".github\" / \"workflows\" / \"mkdocs.yml\"\n    if not action_path.exists():\n        action_path.parent.mkdir(parents=True, exist_ok=True)\n        action_path.write_text(action_template)\n</code></pre>"},{"location":"reference/tests/","title":"Tests","text":""},{"location":"reference/tests/#write_the.tests.write.write_the_tests","title":"<code>write_the_tests(filename, gpt_4=False)</code>","text":"<p>Formats and runs the tests for a given file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Path</code> <p>The path to the file to be tested.</p> required <code>gpt_4</code> <code>bool</code> <p>Whether to use GPT-4 for testing. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted and tested code.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; write_the_tests(Path(\"test.py\"), gpt_4=True)\n\"Formatted and tested code\"\n</code></pre> Source code in <code>write_the/tests/write.py</code> <pre><code>def write_the_tests(\n    filename: Path,\n    gpt_4: bool = False\n) -&gt; str:\n\"\"\"\n    Formats and runs the tests for a given file.\n    Args:\n      filename (Path): The path to the file to be tested.\n      gpt_4 (bool, optional): Whether to use GPT-4 for testing. Defaults to False.\n    Returns:\n      str: The formatted and tested code.\n    Examples:\n      &gt;&gt;&gt; write_the_tests(Path(\"test.py\"), gpt_4=True)\n      \"Formatted and tested code\"\n    \"\"\"\n    with open(filename, \"r\") as file:\n        source_code = file.read()\n    source_code = format_str(source_code, mode=FileMode())\n    result = run(code=source_code, path=filename, gpt_4=gpt_4)\n    code = result.strip().lstrip(\"Test Code:\\n```python\").lstrip(\"```python\").lstrip(\"```\").rstrip(\"```\")\n    return format_str(code, mode=FileMode())\n</code></pre>"},{"location":"reference/tests/#write_the.tests.chain.run","title":"<code>run(code, path, temperature=0, max_tokens=-1, gpt_4=False)</code>","text":"<p>Generates unit tests for a given code snippet using the pytest framework.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>The code snippet to generate tests for.</p> required <code>path</code> <code>str</code> <p>The path to the code snippet.</p> required <code>temperature</code> <code>float</code> <p>The temperature parameter for the OpenAI model. Defaults to 0.</p> <code>0</code> <code>max_tokens</code> <code>int</code> <p>The maximum number of tokens to generate. Defaults to 2000.</p> <code>-1</code> <code>gpt_4</code> <code>bool</code> <p>Whether to use the GPT-4 model. Defaults to False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The generated unit tests.</p> Notes <p>The tests should cover all possible scenarios, including edge cases. The code should be imported from <code>path</code> and any relative imports should be fixed.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; run(code=\"def add(a, b): return a + b\", path=\"my_code.py\")\nimport my_code\n@pytest.mark.parametrize(\"a, b, expected\", [\n    (1, 2, 3),\n    (2, 3, 5),\n    (3, 4, 7)\n])\ndef test_add(a, b, expected):\n    assert my_code.add(a, b) == expected\n</code></pre> Source code in <code>write_the/tests/chain.py</code> <pre><code>def run(code, path, temperature=0, max_tokens=-1, gpt_4=False) -&gt; str:\n\"\"\"\n    Generates unit tests for a given code snippet using the pytest framework.\n    Args:\n      code (str): The code snippet to generate tests for.\n      path (str): The path to the code snippet.\n      temperature (float, optional): The temperature parameter for the OpenAI model. Defaults to 0.\n      max_tokens (int, optional): The maximum number of tokens to generate. Defaults to 2000.\n      gpt_4 (bool, optional): Whether to use the GPT-4 model. Defaults to False.\n    Returns:\n      str: The generated unit tests.\n    Notes:\n      The tests should cover all possible scenarios, including edge cases.\n      The code should be imported from `path` and any relative imports should be fixed.\n    Examples:\n      &gt;&gt;&gt; run(code=\"def add(a, b): return a + b\", path=\"my_code.py\")\n      import my_code\n      @pytest.mark.parametrize(\"a, b, expected\", [\n          (1, 2, 3),\n          (2, 3, 5),\n          (3, 4, 7)\n      ])\n      def test_add(a, b, expected):\n          assert my_code.add(a, b) == expected\n    \"\"\"\n    model_name = \"gpt-4\" if gpt_4 else \"text-davinci-003\"\n    llm = OpenAI(temperature=temperature, max_tokens=max_tokens, model_name=model_name)\n    docs_chain = LLMChain(llm=llm, prompt=docs_prompt)\n    return docs_chain.predict(code=code, path=path)\n</code></pre>"},{"location":"reference/utils/","title":"Utils","text":""},{"location":"reference/utils/#write_the.utils.list_python_files","title":"<code>list_python_files(directory)</code>","text":"<p>Finds all Python files in a given directory.</p> <p>Parameters:</p> Name Type Description Default <code>directory</code> <code>Path</code> <p>The directory to search for Python files.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of Path objects for each Python file found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; list_python_files(Path('/home/user/code'))\n[Path('/home/user/code/main.py'), Path('/home/user/code/utils.py')]\n</code></pre> Source code in <code>write_the/utils.py</code> <pre><code>def list_python_files(directory):\n\"\"\"\n    Finds all Python files in a given directory.\n    Args:\n      directory (Path): The directory to search for Python files.\n    Returns:\n      list: A list of Path objects for each Python file found.\n    Examples:\n      &gt;&gt;&gt; list_python_files(Path('/home/user/code'))\n      [Path('/home/user/code/main.py'), Path('/home/user/code/utils.py')]\n    \"\"\"\n    python_files = []\n    for file in directory.glob(\"**/*.py\"):\n        python_files.append(file)\n    return python_files\n</code></pre>"}]}